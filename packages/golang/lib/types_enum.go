// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package registry

import (
	"errors"
	"fmt"
)

const (
	// APIURLKindBlockscout is a APIURLKind of type blockscout.
	APIURLKindBlockscout APIURLKind = "blockscout"
	// APIURLKindEtherscan is a APIURLKind of type etherscan.
	APIURLKindEtherscan APIURLKind = "etherscan"
	// APIURLKindEthplorer is a APIURLKind of type ethplorer.
	APIURLKindEthplorer APIURLKind = "ethplorer"
	// APIURLKindOther is a APIURLKind of type other.
	APIURLKindOther APIURLKind = "other"
	// APIURLKindSubscan is a APIURLKind of type subscan.
	APIURLKindSubscan APIURLKind = "subscan"
)

var ErrInvalidAPIURLKind = errors.New("not a valid APIURLKind")

// String implements the Stringer interface.
func (x APIURLKind) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x APIURLKind) IsValid() bool {
	_, err := ParseAPIURLKind(string(x))
	return err == nil
}

var _APIURLKindValue = map[string]APIURLKind{
	"blockscout": APIURLKindBlockscout,
	"etherscan":  APIURLKindEtherscan,
	"ethplorer":  APIURLKindEthplorer,
	"other":      APIURLKindOther,
	"subscan":    APIURLKindSubscan,
}

// ParseAPIURLKind attempts to convert a string to a APIURLKind.
func ParseAPIURLKind(name string) (APIURLKind, error) {
	if x, ok := _APIURLKindValue[name]; ok {
		return x, nil
	}
	return APIURLKind(""), fmt.Errorf("%s is %w", name, ErrInvalidAPIURLKind)
}

// MarshalText implements the text marshaller method.
func (x APIURLKind) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *APIURLKind) UnmarshalText(text []byte) error {
	tmp, err := ParseAPIURLKind(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// BytesEncodingBase58 is a BytesEncoding of type base58.
	BytesEncodingBase58 BytesEncoding = "base58"
	// BytesEncodingBase64 is a BytesEncoding of type base64.
	BytesEncodingBase64 BytesEncoding = "base64"
	// BytesEncodingOther is a BytesEncoding of type other.
	BytesEncodingOther BytesEncoding = "other"
	// BytesEncodingHex is a BytesEncoding of type hex.
	BytesEncodingHex BytesEncoding = "hex"
	// BytesEncoding0Xhex is a BytesEncoding of type 0xhex.
	BytesEncoding0Xhex BytesEncoding = "0xhex"
)

var ErrInvalidBytesEncoding = errors.New("not a valid BytesEncoding")

// String implements the Stringer interface.
func (x BytesEncoding) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x BytesEncoding) IsValid() bool {
	_, err := ParseBytesEncoding(string(x))
	return err == nil
}

var _BytesEncodingValue = map[string]BytesEncoding{
	"base58": BytesEncodingBase58,
	"base64": BytesEncodingBase64,
	"other":  BytesEncodingOther,
	"hex":    BytesEncodingHex,
	"0xhex":  BytesEncoding0Xhex,
}

// ParseBytesEncoding attempts to convert a string to a BytesEncoding.
func ParseBytesEncoding(name string) (BytesEncoding, error) {
	if x, ok := _BytesEncodingValue[name]; ok {
		return x, nil
	}
	return BytesEncoding(""), fmt.Errorf("%s is %w", name, ErrInvalidBytesEncoding)
}

// MarshalText implements the text marshaller method.
func (x BytesEncoding) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *BytesEncoding) UnmarshalText(text []byte) error {
	tmp, err := ParseBytesEncoding(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// NetworkTypeDevnet is a NetworkType of type devnet.
	NetworkTypeDevnet NetworkType = "devnet"
	// NetworkTypeMainnet is a NetworkType of type mainnet.
	NetworkTypeMainnet NetworkType = "mainnet"
	// NetworkTypeTestnet is a NetworkType of type testnet.
	NetworkTypeTestnet NetworkType = "testnet"
)

var ErrInvalidNetworkType = errors.New("not a valid NetworkType")

// String implements the Stringer interface.
func (x NetworkType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x NetworkType) IsValid() bool {
	_, err := ParseNetworkType(string(x))
	return err == nil
}

var _NetworkTypeValue = map[string]NetworkType{
	"devnet":  NetworkTypeDevnet,
	"mainnet": NetworkTypeMainnet,
	"testnet": NetworkTypeTestnet,
}

// ParseNetworkType attempts to convert a string to a NetworkType.
func ParseNetworkType(name string) (NetworkType, error) {
	if x, ok := _NetworkTypeValue[name]; ok {
		return x, nil
	}
	return NetworkType(""), fmt.Errorf("%s is %w", name, ErrInvalidNetworkType)
}

// MarshalText implements the text marshaller method.
func (x NetworkType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *NetworkType) UnmarshalText(text []byte) error {
	tmp, err := ParseNetworkType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ProtocolArweave is a Protocol of type arweave.
	ProtocolArweave Protocol = "arweave"
	// ProtocolCosmos is a Protocol of type cosmos.
	ProtocolCosmos Protocol = "cosmos"
	// ProtocolEthereum is a Protocol of type ethereum.
	ProtocolEthereum Protocol = "ethereum"
	// ProtocolNear is a Protocol of type near.
	ProtocolNear Protocol = "near"
	// ProtocolOther is a Protocol of type other.
	ProtocolOther Protocol = "other"
	// ProtocolStarknet is a Protocol of type starknet.
	ProtocolStarknet Protocol = "starknet"
)

var ErrInvalidProtocol = errors.New("not a valid Protocol")

// String implements the Stringer interface.
func (x Protocol) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Protocol) IsValid() bool {
	_, err := ParseProtocol(string(x))
	return err == nil
}

var _ProtocolValue = map[string]Protocol{
	"arweave":  ProtocolArweave,
	"cosmos":   ProtocolCosmos,
	"ethereum": ProtocolEthereum,
	"near":     ProtocolNear,
	"other":    ProtocolOther,
	"starknet": ProtocolStarknet,
}

// ParseProtocol attempts to convert a string to a Protocol.
func ParseProtocol(name string) (Protocol, error) {
	if x, ok := _ProtocolValue[name]; ok {
		return x, nil
	}
	return Protocol(""), fmt.Errorf("%s is %w", name, ErrInvalidProtocol)
}

// MarshalText implements the text marshaller method.
func (x Protocol) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *Protocol) UnmarshalText(text []byte) error {
	tmp, err := ParseProtocol(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// RelationKindBeaconOf is a RelationKind of type beaconOf.
	RelationKindBeaconOf RelationKind = "beaconOf"
	// RelationKindEvmOf is a RelationKind of type evmOf.
	RelationKindEvmOf RelationKind = "evmOf"
	// RelationKindOther is a RelationKind of type other.
	RelationKindOther RelationKind = "other"
	// RelationKindForkedFrom is a RelationKind of type forkedFrom.
	RelationKindForkedFrom RelationKind = "forkedFrom"
	// RelationKindL2Of is a RelationKind of type l2Of.
	RelationKindL2Of RelationKind = "l2Of"
	// RelationKindShardOf is a RelationKind of type shardOf.
	RelationKindShardOf RelationKind = "shardOf"
	// RelationKindTestnetOf is a RelationKind of type testnetOf.
	RelationKindTestnetOf RelationKind = "testnetOf"
)

var ErrInvalidRelationKind = errors.New("not a valid RelationKind")

// String implements the Stringer interface.
func (x RelationKind) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x RelationKind) IsValid() bool {
	_, err := ParseRelationKind(string(x))
	return err == nil
}

var _RelationKindValue = map[string]RelationKind{
	"beaconOf":   RelationKindBeaconOf,
	"beaconof":   RelationKindBeaconOf,
	"evmOf":      RelationKindEvmOf,
	"evmof":      RelationKindEvmOf,
	"other":      RelationKindOther,
	"forkedFrom": RelationKindForkedFrom,
	"forkedfrom": RelationKindForkedFrom,
	"l2Of":       RelationKindL2Of,
	"l2of":       RelationKindL2Of,
	"shardOf":    RelationKindShardOf,
	"shardof":    RelationKindShardOf,
	"testnetOf":  RelationKindTestnetOf,
	"testnetof":  RelationKindTestnetOf,
}

// ParseRelationKind attempts to convert a string to a RelationKind.
func ParseRelationKind(name string) (RelationKind, error) {
	if x, ok := _RelationKindValue[name]; ok {
		return x, nil
	}
	return RelationKind(""), fmt.Errorf("%s is %w", name, ErrInvalidRelationKind)
}

// MarshalText implements the text marshaller method.
func (x RelationKind) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *RelationKind) UnmarshalText(text []byte) error {
	tmp, err := ParseRelationKind(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
